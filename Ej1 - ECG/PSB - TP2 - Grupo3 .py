# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'VERSIONFINAL.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from pyqtgraph import PlotWidget
from brainflow.board_shim import BoardShim, BrainFlowInputParams, BoardIds
from brainflow.data_filter import DataFilter
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
import scipy.signal as sig
import scipy.io as sio
import pandas as pd
from pyqtgraph import GraphicsLayoutWidget

import datetime


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1212, 734)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.controles = QtWidgets.QGroupBox(self.centralwidget)
        self.controles.setObjectName("controles")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.controles)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.conexion = QtWidgets.QGroupBox(self.controles)
        self.conexion.setObjectName("conexion")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.conexion)
        self.verticalLayout_3.setObjectName("verticalLayout_3")

        # Boton de conexion
        self.cytonButton = QtWidgets.QPushButton(self.conexion)
        self.cytonButton.setObjectName("cytonButton")
        self.cytonButton.clicked.connect(self.comunica_cyton)

        self.verticalLayout_3.addWidget(self.cytonButton)
        self.horizontalLayout.addWidget(self.conexion)
        self.registrar = QtWidgets.QGroupBox(self.controles)
        self.registrar.setObjectName("registrar")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.registrar)
        self.verticalLayout_4.setObjectName("verticalLayout_4")

        # Boton de inicio
        self.startButton = QtWidgets.QPushButton(self.registrar)
        self.startButton.setObjectName("startButton")
        self.startButton.clicked.connect(self.iniciar_registro)

        self.verticalLayout_4.addWidget(self.startButton)

        # Boton de fin
        self.endButton = QtWidgets.QPushButton(self.registrar)
        self.endButton.setObjectName("endButton")
        self.endButton.clicked.connect(self.fin_registro)


        self.verticalLayout_4.addWidget(self.endButton)
        self.horizontalLayout.addWidget(self.registrar)
        self.frecuenciabox = QtWidgets.QGroupBox(self.controles)
        self.frecuenciabox.setObjectName("frecuenciabox")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.frecuenciabox)
        self.verticalLayout_5.setObjectName("verticalLayout_5")

        # Label de frecuencia
        self.frecValue = QtWidgets.QLabel(self.frecuenciabox)
        self.frecValue.setObjectName("frecValue")
        self.frecValue.setText('0 latidos/minuto')

        self.verticalLayout_5.addWidget(self.frecValue)
        self.archivo = QtWidgets.QGroupBox(self.frecuenciabox)
        self.archivo.setObjectName("archivo")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.archivo)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.nameArchivo = QtWidgets.QLineEdit(self.archivo)

        # Line edit de nombre de archivo
        self.nameArchivo.setObjectName("nameArchivo")

        self.verticalLayout_6.addWidget(self.nameArchivo)
        self.verticalLayout_5.addWidget(self.archivo)
        self.horizontalLayout.addWidget(self.frecuenciabox)
        self.horizontalLayout_2.addLayout(self.horizontalLayout)
        self.verticalLayout.addWidget(self.controles)

        # Grafica
        # self.grafico = QtWidgets.QGraphicsView(self.centralwidget)
        # self.grafico.setObjectName("grafico")
        self.grafico = PlotWidget(self.centralwidget) # create a plot widget
        self.grafico.setObjectName("grafico")

        self.verticalLayout.addWidget(self.grafico)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Tp 2 - PSB - GRUPO 3"))
        self.controles.setTitle(_translate("MainWindow", "Controles"))
        self.conexion.setTitle(_translate("MainWindow", "Conectar"))
        self.cytonButton.setText(_translate("MainWindow", "Open BCI"))
        self.registrar.setTitle(_translate("MainWindow", "Registrar"))
        self.startButton.setText(_translate("MainWindow", "Inicio"))
        self.endButton.setText(_translate("MainWindow", "Fin"))
        self.frecuenciabox.setTitle(_translate("MainWindow", "Frecuencia"))
        self.archivo.setTitle(_translate("MainWindow", "Ingrese nombre del archivo"))


    ##########################################
    # METODOS PROPIOS
    ##########################################
    ###########################################################################################################################################
    '''La siguiente función permite la conexión con la placa openBCI para luego obtener los datos que provienen de esta'''
    ###########################################################################################################################################
    def comunica_cyton(self):

        #Para leer datos de la placa con info detallada 
        BoardShim.enable_dev_bpantompkinsoard_logger()
    
        #Parametros de entrada para el método de prepare_session
        params=BrainFlowInputParams()
        #Puerto serie de donde se van a leer los datos --> Fijarnos cual es en nuestro caso
        params.serial_port='COM7'

        board_id = BoardIds.CYTON_BOARD.value 
        self.board = BoardShim(board_id, params)
    
        #Prepara la transmisión
        self.board.prepare_session()

        #Configuración de los comandos
    
        #Se ponen todos los canales en Default 
        self.board.congif_board('d')

        #Configuracion del canal 1 -> Encendido // Ganancia de 24 // Fuente de entrada del canal ADC // Generación de BIAS // Desconecta entrada con SRB2 // Desconecta entrada con SRB1
        self.board.config_board('x1060100X')

        #Apaga los demas canales
        self.board.config_board('2')
        self.board.config_board('3')
        self.board.config_board('4')
        self.board.config_board('5')
        self.board.config_board('6')
        self.board.config_board('7')
        self.board.config_board('8')

    ###########################################################################################################################################
    '''Para iniciar el registro de la placa OpenBCI se debe apretar inicio registro que hace lo siguiente'''
    ###########################################################################################################################################
    
    def iniciar_registro(self):
        print("Inicio del registro de datos")
        self.board.start_stream(900000)                                                                     #Comienza a transmitir los datos y los guarda en un buffer de 900k
        
        self.Fs=250
        self.vector = np.ndarray(shape=(1), dtype= np.float64)
        self.guardar = np.ndarray(shape=(1), dtype= np.float64)
        self.tiempo=[]
        self.guardart=[]
     
        self.contador=0                                                                                     #Contador y timer para iniciar el bucle
        self.timerB = QtCore.QTimer()
        self.timerB.timeout.connect(self.bucleBCI)
        self.timerB.start(2000)

    ###########################################################################################################################################
    '''Bucle para el OpenBCI'''
    ###########################################################################################################################################

    def bucleBCI(self):
        
        tiempo=np.arange(2*self.contador, 2+2*self.contador,1/self.Fs)                                      #Vector con los segundos
        self.contador+=1
        paquete=self.board.get_board_data()                                                                 #Obtiene datos de la placa y los elimina (2seg con f = 250 -> 500 muestras)
        paquete=paquete[1]                                                                                  #Nos quedamos con el canal ECG = 1 ¿?
        self.guardar = np.hstack((self.guardar, paquete))                                                   #Guarda datos para el archivo CSV
        self.vector = np.hstack((self.vector, paquete))         
        self.tiempo = np.hstack((self.tiempo, tiempo))      ## tiempo para el grafico, chequear si esta bien                                                   

        if (len(self.vector)> (10*self.Fs)):                                                                #Si el vector tiene 10seg (12seg) 
            self.vector=self.vector[(2*self.Fs):]                                                           #Se eliminan 2seg para que quede en 10seg
            self.tiempo=self.tiempo[(2*self.Fs):]
            self.deteccion_QRS(self.vector,self.Fs)                                                         #Calcula la frecuencia cardiaca a partir de 10seg 

        self.graficar(self.vector,self.tiempo)                                                              #Va graficando la señal ECG cada 2seg

    
    ###########################################################################################################################################
    '''Función para graficar en la interfaz'''
    ###########################################################################################################################################

    def graficar(self,vector,tiempo):
        self.grafico.clear()                                                                         
        self.grafico.plot(tiempo,vector)                                                              
        self.grafico.showLabel('left',show=True)
        self.grafico.showLabel('bottom',show=True)
        self.grafico.setLabels(title="Señal ECG",bottom="Tiempo [s]",left="Amplitud [uV]")


    ###########################################################################################################################################
    '''Detección QRS'''
    ###########################################################################################################################################

    def deteccion_QRS(self,señal,fs):

        copia=señal.copy()

        #1. Preacondicionamiento: Pasa banda 5 a 15Hz                                                                         
        w1=5*2/fs                                                                                   #Frecuencias de corte       
        w2=15*2/fs
        N=3                                                                                         #Orden del filtro
        b,a=sig.butter(N,[w1,w2],'bandpass',analog=False)                                           #Coeficientes del filtro IIR (b numerador, a denominador)

        señal=sig.filtfilt(b,a,señal,axis=0)                                                        #Se le aplica el filtro a la señal            
        ecg_b= señal/np.max(np.abs(señal))                                                          #ECG con preacondicionamiento normalizado

        '''#Grafico de la señal filtrada 
        plt.plot(ecg_b)
        plt.title("Preacondicionamiento ECG: Filtro pasa-banda")
        plt.xlabel("Muestras")
        plt.ylabel("Amplitud normalizada")
        plt.show()'''

        #2. Filtro derivativo

        b = [1*fs/8,2*fs/8,0,-2*fs/8,-1*fs/8]                                                       #Coeficientes del filtro derivativo
        ecg_d=sig.filtfilt(b,1,ecg_b)                                                               #Se le aplica el filtro
        ecg_d=ecg_d/np.max(ecg_d)                                                                   #Se normaliza 

        '''#Grafico de la señal  
        if (self.contador==1):
                plt.plot(ecg_d)
                plt.title("ECG luego del filtro derivativo")
                plt.xlabel("Muestras")
                plt.ylabel("Amplitud normalizada")
                plt.show()'''

        #3. Cuadrado: Se eleva la señal obtenida en el punto anterior para que quede todo positivo 

        ecg_c= np.power(ecg_d,2)                                                                    

        '''#Grafico
        if (self.contador==1):
                plt.plot(ecg_c)
                plt.title("ECG luego de elevar al cuadrado")
                plt.xlabel("Muestras")
                plt.ylabel("Amplitud normalizada")
                plt.show()'''

        #4. Integración: Se integra para saber cuales picos son realmente QRS (duran más tiempo) y cuales no 

        L=round(0.150*fs)                                                                               #Tamaño de la ventana
        ecg_i= np.zeros(len(ecg_c))
        suma=0

        for i in range(L):                                                                              #Primera ventana           
            suma+=ecg_c[i]
            ecg_i[i]=suma/L

        for i in range(L,len(ecg_c)):                                                                 
            suma+=ecg_c[i]
            suma-=ecg_c[i-L]
            ecg_i[i]=suma/L

        '''#Grafico
        if (self.contador==1):
                plt.plot(ecg_i)
                plt.title("ECG luego de integrar")
                plt.xlabel("Muestras")
                plt.ylabel("Amplitud normalizada")
                plt.show()'''

        #Buscamos cuantos picos QRS hay

        picos,_= sig.find_peaks(ecg_i,height=0.20,distance=0.75*fs)                                     #Función que devuelve el indice de los picos, la altura y distancia se determino al observar el ECG de prueba       
        frecuencia=len(picos)*6                                                                         #Calculo de la frecuencia cardiaca = picos QRS cada 10seg * 6 = picos QRS o latidos por minuto
        frecV=str(frecuencia) + 'latidos/min'                                                           #Se pasa a string para mostrar en la interfaz
        self.frecValue.setText(frecV)

    ###########################################################################################################################################
    '''Finalización del registro: Se para el Timer para que deje de hacer el bucle, luego se para de transmitir y se cierra la sesión con la placa'''
    ###########################################################################################################################################

    def fin_registro(self):

        print("Fin del registro")
        self.timerB.stop()                                                                              #Se para de realizar el ciclo de bucleBCI                                                     
        self.board.stop_stream()                                                                        #Deja de transmitir
        self.board.release_session()                                                                    #Se cierra la sesión con la placa

        #data={'Tiempo [s]': self.guardart, 'ECG [uV]': self.guardar}                                   #Diccionario con los datos de toda la sesión
        data={'ECG [uV]': self.guardar}     
        df=pd.DataFrame(data)          
        
        #Se guardan los datos en un archivo csv
        auxName = self.nameArchivo.text()      
        if (auxName.strip()) == "":                                                                     #Si no se ingreso un nombre de archivo o son espacios se guarda con el nombre por defecto
            df.to_csv('ECG' + datetime.now().strftime("%m/%d/%Y, %H:%M:%S") +'.csv',index=False)        #Se guarda con el nombre de la fecha y hora (SIEMPRE ES UN ARCHIVO NUEVO)
        else:
            df.to_csv(auxName.strip()+'.csv',index=False)                                       #Se guarda con el nombre que se ingreso en la interfaz si el usuario lo ingresa


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
